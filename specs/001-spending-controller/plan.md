# Implementation Plan: Spending Controller

**Branch**: `001-spending-controller` | **Date**: 2026-01-01 | **Spec**: [spec.md](./spec.md)

## Summary

Refactor spending calculation from a static method to a Controller-based architecture following the established allocation Controller pattern. Implement an `inflation_following` strategy that selects appropriate spending profiles based on simulation date and applies inflation adjustment. This refactoring maintains calculation accuracy while providing an extensible foundation for future spending strategies.

## Technical Context

**Language/Version**: Python 3.10+  
**Primary Dependencies**: pydantic (for config models), numpy (for calculations), dataclasses (for strategy classes)  
**Storage**: N/A (configuration-driven, no persistence layer)  
**Testing**: pytest with fixtures  
**Target Platform**: Python application (simulator + Flask API)  
**Project Type**: Single project (financial simulation engine)  
**Performance Goals**: <1ms per spending calculation; maintain current simulation performance  
**Constraints**: Must maintain backward compatibility with existing State object structure; zero or negative inflation must be supported  
**Scale/Scope**: Refactor affecting 3-5 files; ~200-300 lines of new code; existing test suite must pass

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Code Quality Gates:**
- [x] All code will include type hints for public functions and classes
- [x] Code will pass Ruff linting checks as configured in pyproject.toml
- [x] Code will pass Ruff formatting checks
- [x] Code will pass Pyright type checking as configured in pyrightconfig.json
- [x] All modules will include module-level docstrings
- [x] All public classes and functions will include docstrings
- [x] No circular dependencies will be introduced
- [x] Object models (classes, dataclasses, TypedDict, Pydantic) will be used instead of plain dictionaries for type safety
- [x] Function calls will use named arguments (except single obvious argument cases)

**Testing Gates:**
- [x] Test-Driven Development (TDD) will be used: tests written before implementation for all application code
- [x] Test coverage plan achieves minimum 80% (95%+ for financial calculations) for application code (simulator and Flask app)
- [x] Tests will use pytest framework with proper, reusable fixtures (including shared domain fixtures and factories where appropriate)
- [x] Tests will be designed to be data-driven where feasible (avoiding duplicated "magic numbers" by deriving expectations from shared fixtures, canonical data files, or domain objects)
- [x] Integration tests planned for API endpoints
- [x] Test performance targets defined (<1s unit, <10s integration)
- [x] No standalone scripts/notebooks involved in this feature

**User Experience Gates:**
- [x] API endpoints follow consistent naming conventions (no API changes, internal refactoring only)
- [x] Error messages will be clear and actionable (validation errors specify which profile/field is invalid)
- [x] Response time targets defined (<2s for interactive endpoints; no change expected)
- [x] Configuration validation planned (fail-fast at initialization with clear error messages)

**Performance Gates:**
- [x] Performance benchmarks defined for simulation operations (<1ms per spending calculation)
- [x] Profiling strategy identified for critical paths (profile spending calculation before/after refactoring)
- [x] Memory usage constraints considered (minimal - one controller instance per trial, lightweight strategy objects)
- [x] Scalability considerations documented (linear scaling with number of profiles; typically 2-5 profiles per config)

## Project Structure

### Documentation (this feature)

```text
specs/001-spending-controller/
├── plan.md              # This file
├── research.md          # Phase 0: Controller pattern research
├── data-model.md        # Phase 1: Spending entities and relationships
├── quickstart.md        # Phase 1: Quick reference for spending controller usage
├── contracts/           # Phase 1: API contracts (if applicable)
│   └── spending_config_schema.json  # Pydantic schema for spending_strategy config
└── tasks.md             # Phase 2: Generated by /speckit.tasks (NOT created here)
```

### Source Code (repository root)

```text
app/
├── models/
│   ├── config/
│   │   ├── spending.py           # UPDATE: Refactor config classes
│   │   └── strategy.py           # REFERENCE: StrategyConfig base class
│   ├── controllers/
│   │   ├── __init__.py           # UPDATE: Add spending controller to Controllers dataclass
│   │   ├── allocation.py         # REFERENCE: Pattern to follow
│   │   └── spending.py           # NEW: Spending controller module
│   └── financial/
│       └── state_change.py       # UPDATE: Replace _calc_spending with controller call
│
tests/
├── conftest.py                  # UPDATE: Add reusable fixtures for spending profiles and State objects
├── models/
│   ├── config/
│   │   └── test_spending.py      # UPDATE: Add validation tests for new config structure
│   ├── controllers/
│   │   └── test_spending.py      # NEW: Controller and strategy tests
│   └── financial/
│       └── test_state_change.py  # UPDATE: Update tests to use controller
└── sample_configs/
    └── full_config.yml            # UPDATE: Convert to new config format
```

**Structure Decision**: Single project structure. This is an internal refactoring of the financial simulation engine. The spending controller follows the established controllers pattern located in `app/models/controllers/`. Configuration changes affect `app/models/config/spending.py`, and integration requires updates to `app/models/financial/state_change.py` and the `Controllers` dataclass.

## Complexity Tracking

No constitutional violations. This feature adheres to all constitution principles without requiring exceptions.
